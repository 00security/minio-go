/*
 * Minio Go Library for Amazon S3 Compatible Cloud Storage (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package minio

import (
	"encoding/base64"
	"encoding/hex"
	"io"
	"net/http"
	"net/url"
)

// Request - a http request.
type Request struct {
	req          *http.Request
	credentials  *clientCredentials
	transport    http.RoundTripper
	bucketRegion string
	expires      int64
}

// requestMetadata - is container for all the values to make a request.
type requestMetadata struct {
	// User supplied.
	expires          int64
	userAgent        string
	bucketRegion     string
	credentials      *clientCredentials
	contentTransport http.RoundTripper
	contentHeader    http.Header

	// Generated by our internal code.
	contentBody        io.ReadCloser
	contentLength      int64
	contentSha256Bytes []byte
	contentMD5Bytes    []byte
}

// getTargetURL - construct a encoded URL for the requests.
func getTargetURL(endpoint *url.URL, bucketName, objectName string, queryValues url.Values) (*url.URL, error) {
	var urlStr string
	// If endpoint supports virtual host style use that always.
	// Currently only S3 and Google Cloud Storage would support this.
	if isVirtualHostSupported(endpoint) {
		urlStr = endpoint.Scheme + "://" + bucketName + "." + endpoint.Host
		urlStr = urlStr + "/" + urlEncodePath(objectName)
	} else {
		// If not fall back to using path style.
		urlStr = endpoint.Scheme + "://" + endpoint.Host + "/" + bucketName
		if objectName != "" {
			urlStr = urlStr + "/" + urlEncodePath(objectName)
		}
	}
	// If there are any query values, add them to the end.
	if len(queryValues) > 0 {
		urlStr = urlStr + "?" + queryValues.Encode()
	}
	u, err := url.Parse(urlStr)
	if err != nil {
		return nil, err
	}
	return u, nil
}

// Do - start the request.
func (r *Request) Do() (resp *http.Response, err error) {
	// if not an anonymous request, calculate relevant signature.
	if !isAnonymousCredentials(*r.credentials) {
		if r.credentials.Signature.isV2() {
			// if signature version '2' requested, use that.
			r.SignV2()
		}
		if r.credentials.Signature.isV4() || r.credentials.Signature.isLatest() {
			// Not a presigned request, set behavior to default.
			r.SignV4()
		}
	}
	// Use custom transport if any.
	transport := http.DefaultTransport
	if r.transport != nil {
		transport = r.transport
	}
	client := &http.Client{Transport: transport}
	return client.Do(r.req)
}

// Set - set additional headers if any.
func (r *Request) Set(key, value string) {
	r.req.Header.Set(key, value)
}

// Get - get header values.
func (r *Request) Get(key string) string {
	return r.req.Header.Get(key)
}

// newRequest - provides a new instance of *Request*.
func newRequest(method string, targetURL *url.URL, metadata requestMetadata) (*Request, error) {
	if method == "" {
		method = "POST"
	}
	urlStr := targetURL.String()
	// get a new HTTP request, for the requested method.
	req, err := http.NewRequest(method, urlStr, nil)
	if err != nil {
		return nil, err
	}

	// Set content body if available.
	if metadata.contentBody != nil {
		req.Body = metadata.contentBody
	}

	// save for subsequent use.
	r := new(Request)
	r.req = req
	r.credentials = metadata.credentials
	r.bucketRegion = metadata.bucketRegion

	// If presigned request, return.
	if metadata.expires != 0 {
		r.expires = metadata.expires
		return r, nil
	}

	// set UserAgent for the request.
	r.Set("User-Agent", metadata.userAgent)

	// Set all headers.
	for k, v := range metadata.contentHeader {
		r.Set(k, v[0])
	}

	// set incoming content-length.
	if metadata.contentLength > 0 {
		r.req.ContentLength = metadata.contentLength
	}

	// set sha256 sum for signature calculation only with signature version '4'.
	if r.credentials.Signature.isV4() || r.credentials.Signature.isLatest() {
		r.Set("X-Amz-Content-Sha256", hex.EncodeToString(sum256([]byte{})))
		if metadata.contentSha256Bytes != nil {
			r.Set("X-Amz-Content-Sha256", hex.EncodeToString(metadata.contentSha256Bytes))
		}
	}

	// set md5Sum for content protection.
	if metadata.contentMD5Bytes != nil {
		r.Set("Content-MD5", base64.StdEncoding.EncodeToString(metadata.contentMD5Bytes))
	}

	// return request.
	return r, nil
}
